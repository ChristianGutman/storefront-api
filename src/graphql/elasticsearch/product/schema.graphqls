scalar JSON

type Products implements ESResponseInterface @doc(description: "The Products object is the top-level object returned in a product search") {
    items: [Product] @doc(description: "An array of products that match the specified search criteria")
    page_info: SearchResultPageInfo @doc(description: "An object that includes the page_info and currentPage values specified in the query")
    total_count: Int @doc(description: "The number of products returned")
    aggregations: JSON @doc(description: "Layered navigation filters array as aggregations")
    sort_fields: SortFields @doc(description: "An object that includes the default sort field and all available sort fields")
    hits: JSON
    suggest: JSON
}

extend type Query {
    products (
        search: String @doc(description: "Performs a full-text search using the specified key words."),
        filter: ProductFilterInput @doc(description: "Identifies which product attributes to search for and return."),
        pageSize: Int = 20 @doc(description: "Specifies the maximum number of results to return at once. This attribute is optional."),
        currentPage: Int = 1 @doc(description: "Specifies which page of results to return. The default value is 1."),
        sort: ProductSortInput @doc(description: "Specifies which attribute to sort on, and whether to return the results in ascending or descending order."),
        _sourceInclude: [String] @doc(description: "Specifies which attribute we include in result.")
        _sourceExclude: [String] @doc(description: "Specifies which attribute we exclude in result.")
        ): Products
    product ( 
        sku: String @doc(description: "Get Single product by it's SKU")
        id: ID @doc(description: "Get Single product by it's ID")
        url_path: String @doc(description: "Get Single product by it's url_path")
        _sourceInclude: [String] @doc(description: "Specifies which attribute we include in result.")
        _sourceExclude: [String] @doc(description: "Specifies which attribute we exclude in result.")        
        ): Product
}

type SearchResultPageInfo @doc(description: "SearchResultPageInfo provides navigation for the query response") {
    page_size: Int @doc(description: "Specifies the maximum number of items to return")
    current_page: Int @doc(description: "Specifies which page of results to return")
}

input FilterTypeInput @doc(description: "FilterTypeInput specifies which action will be performed in a query ") {
    eq: JSON @doc(description: "Equals")
    finset: [String] @doc(description: "Find in set. The value can contain a set of comma-separated values")
    from: String @doc(description: "From. Must be used with 'to'")
    gt: String @doc(description: "Greater than")
    gte: String @doc(description: "Greater than or equal to")
    gteq: String @doc(description: "Greater than or equal to")
    in: [JSON] @doc(description: "In. The value can contain a set of comma-separated values")
    like: String @doc(description: "Like. The specified value can contain % (percent signs) to allow matching of 0 or more characters")
    lt: String @doc(description: "Less than")
    lte: String @doc(description: "Less than or equal to")
    lteq: String @doc(description: "Less than or equal to")
    moreq: String @doc(description: "More than or equal to")
    neq: JSON @doc(description: "Not equal to")
    notnull: String @doc(description: "Not null")
    null: String @doc(description: "Is null")
    to: String@doc(description: "To. Must be used with 'from'")
    nin: [String] @doc(description: "Not in. The value can contain a set of comma-separated values")
    scope: [String] @doc(description: "describe the filter scope (default | catalog)")
}

input ProductSortInput {
    name: SortEnum @doc(description: "The product name. Customers use this name to identify the product.")
    sku: SortEnum @doc(description: "A number or code assigned to a product to identify the product, options, price, and manufacturer")
    description: SortEnum @doc(description: "Detailed information about the product. The value can include simple HTML tags.")
    short_description: SortEnum @doc(description: "A short description of the product. Its use depends on the theme.")
    price: SortEnum @doc(description: "The price of the item")
    final_price: SortEnum @doc(description: "The price of the item")
    special_price: SortEnum @doc(description: "The discounted price of the product")
    special_from_date: SortEnum @doc(description: "The beginning date that a product has a special price")
    special_to_date: SortEnum @doc(description: "The end date that a product has a special price")
    weight: SortEnum @doc(description: "The weight of the item, in units defined by the store")
    manufacturer: SortEnum @doc(description: "A number representing the product's manufacturer")
    meta_title: SortEnum @doc(description: "A string that is displayed in the title bar and tab of the browser and in search results lists")
    meta_keyword: SortEnum @doc(description: "A comma-separated list of keywords that are visible only to search engines")
    meta_description: SortEnum @doc(description: "A brief overview of the product for search results listings, maximum 255 characters")
    image: SortEnum @doc(description: "The relative path to the main image on the product page")
    small_image: SortEnum @doc(description: "The relative path to the small image, which is used on catalog pages")
    thumbnail: SortEnum @doc(description: "The relative path to the product's thumbnail image")
    tier_price: SortEnum @doc(description: "The price when tier pricing is in effect and the items purchased threshold has been reached")
    news_from_date: SortEnum @doc(description: "The beginning date for new product listings, and determines if the product is featured as a new product")
    news_to_date: SortEnum @doc(description: "The end date for new product listings")
    custom_layout_update: SortEnum @doc(description: "XML code that is applied as a layout update to the product page")
    options_container: SortEnum @doc(description: "If the product has multiple options, determines where they appear on the product page")
    required_options: SortEnum @doc(description: "Indicates whether the product has required options")
    has_options: SortEnum @doc(description: "Indicates whether additional attributes have been created for the product")
    image_label: SortEnum @doc(description: "The label assigned to a product image")
    small_image_label: SortEnum @doc(description: "The label assigned to a product's small image")
    thumbnail_label: SortEnum @doc(description: "The label assigned to a product's thumbnail image")
    created_at: SortEnum @doc(description: "Timestamp indicating when the product was created")
    updated_at: SortEnum @doc(description: "Timestamp indicating when the product was updated")
    country_of_manufacture: SortEnum @doc(description: "The product's country of origin")
    custom_layout: SortEnum @doc(description: "The name of a custom layout")
    gift_message_available: SortEnum @doc(description: "Indicates whether a gift message is available")
}

type Product @doc(description: "ProductFieldsInput defines the product fields to be used in the search.") {
    id: Int @doc(description: "The product id")
    type_id: String @doc(description: "The product type - simple, configurable, virtual, downloadable, grouped")    
    visibility: Int @doc(description: "The product visibility. Customers use this visibility to identify the product.")
    status: Int  @doc(description: "The product status. Customers use this status to identify the product.")
    name: String @doc(description: "The product name. Customers use this name to identify the product.")
    sku: String @doc(description: "A number or code assigned to a product to identify the product, options, price, and manufacturer")
    description: String @doc(description: "Detailed information about the product. The value can include simple HTML tags.")
    short_description: String @doc(description: "A short description of the product. Its use depends on the theme.")   
    price: Float @doc(description: "The price of an item")
    price_incl_tax: Float @doc(description: "The price of an item")
    price_tax: Float @doc(description: "The price of an item")
    final_price: Float @doc(description: "The final price of an item")
    final_price_incl_tax: Float @doc(description: "The price of an item")
    final_price_tax: Float @doc(description: "The price of an item")
    original_price: Float @doc(description: "The price of an item")
    original_price_incl_tax: Float @doc(description: "The price of an item")
    original_price_tax: Float @doc(description: "The price of an item")
    min_price: Float @doc(description:"The numeric minimal price of the product. Do not include the currency code.")
    max_price: Float @doc(description:"The numeric maximal price of the product. Do not include the currency code.")
    special_price: Float @doc(description: "The discounted price of the product")
    special_price_incl_tax: Float @doc(description: "The discounted price of the product")
    special_price_tax: Float @doc(description: "The discounted price of the product")
    special_from_date: String @doc(description: "The beginning date that a product has a special price")
    special_to_date: String @doc(description: "The end date that a product has a special price")
    weight: Float @doc(description: "The weight of the item, in units defined by the store")
    manufacturer: String @doc(description: "A number representing the product's manufacturer")
    meta_title: String @doc(description: "A string that is displayed in the title bar and tab of the browser and in search results lists")
    meta_keyword: String @doc(description: "A comma-separated list of keywords that are visible only to search engines")
    meta_description: String @doc(description: "A brief overview of the product for search results listings, maximum 255 characters")
    image: String @doc(description: "The relative path to the main image on the product page")
    small_image: String @doc(description: "The relative path to the small image, which is used on catalog pages")
    thumbnail: String @doc(description: "The relative path to the product's thumbnail image")
    tier_price: Float @doc(description: "The price when tier pricing is in effect and the items purchased threshold has been reached")
    tier_prices: [ProductTierPrice] @doc(description: "Product tier prices")
    news_from_date: String @doc(description: "The beginning date for new product listings, and determines if the product is featured as a new product")
    news_to_date: String @doc(description: "The end date for new product listings")
    required_options: Boolean @doc(description: "Indicates whether the product has required options")
    has_options: Boolean @doc(description: "Indicates whether additional attributes have been created for the product")
    image_label: String @doc(description: "The label assigned to a product image")
    small_image_label: String @doc(description: "The label assigned to a product's small image")
    thumbnail_label: String @doc(description: "The label assigned to a product's thumbnail image")
    country_of_manufacture: String @doc(description: "The product's country of origin")
    gift_message_available: Boolean @doc(description: "Indicates whether a gift message is available")
    created_at: String @doc(description: "Timestamp indicating when the product was created")
    updated_at: String @doc(description: "Timestamp indicating when the product was updated")
    size: String @doc(description: "The product size. Customers use this size to identify the product.")
    size_options: [String] @doc(description: "The product sizes for all configurable_children variants. Customers use this size to identify the product.")
    color: String @doc(description: "The product color. Customers use this color to identify the product.")
    color_options: [String] @doc(description: "The product colors for all configurable_children variants. Customers use this color to identify the product.")
    category_ids: [String] @doc(description: "Category ID the product belongs to")    
    categories: [Category] @doc(description: "The product categories. It executes additional query to fetch full category objects")
    category: [CategoryBinding] @doc(description: "The product categories. This is just a simplified object with no structure")
    configurable_children: [Product] @doc(description: "Configurable product childrens")
    stock: StockItem @doc(description: "The product stock. Customers use this stock to identify the product.")
    is_in_stock: Boolean @doc(description: "Is product in stock")
    keyword: String @doc(description: "keyword filter input")
    media_gallery: [MediaGalleryItem] @doc(description: "Media items assigned to this specific product")
    configurable_options: [ConfigurableOption] @doc(description: "Configurable attributes for this product")
    #custom_options: [CustomOption] @doc(description: "Custom options for this product")
    bundle_options: [BundleOption] @doc(description: "Bundle options for this product")
    #links: [ProductLinks] @doc(description: "Bundle options for this product")
    reviews (
        search: String @doc(description: "Performs a full-text search using the specified key words."),
        filter: ReviewFilterInput @doc(description: "An array of categories that match the specified search criteria"),
        pageSize: Int = 20 @doc(description: "Specifies the maximum number of results to return at once. This attribute is optional."),
        currentPage: Int = 1 @doc(description: "Specifies which page of results to return. The default value is 1."),
        _sourceInclude: [String] @doc(description: "Specifies which attribute we include in result.")
        _sourceExclude: [String] @doc(description: "Specifies which attribute we exclude in result.")
        ): Reviews @doc(description: "Get the product reviews")
}

type BundleOption @doc(description: "A single option defined for bundle products") {
    option_id: Int @doc(description: "Option identifier")
    position: Int @doc(description: "Option position")
    title: String @doc(description: "Option name")
    type: String @doc(description: "Option type - radio, text ...")
    sku: String @doc(description: "Product assigned with this option")
    required: Boolean @doc(description: "If this option is required")
    product_links: [BundleOptionLink] @doc(description: "Link to the simple products assigned with this option")
}

type BundleOptionLink @doc(description: "Link to the product") {
    price: Float @doc(description: "Price of this sub-product")
    qty: Float @doc(description: "The default quantity of this product in the bundle")
    can_change_quantity: Boolean @doc(description: "If user may change the quantity")
    option_id: Int @doc(description: "Option identifier to which this link is related to")
    id: Int @doc(description: "Unique product link identifier")
    sku: String @doc(description: "Product assigned with this option")
    product: Product @doc(description: "Product related to this bundle link")
    position: Int @doc(description: "Product position")
}

type ConfigurableOptionValue @doc(description: "One single option available for given cofigurable option") {
    value_index: Int @doc(description: "Incremental value index")
    label: String @doc(description: "Option label")
}

type ConfigurableOption @doc(description: "Product configurable option used for the cofnigurable products") {
    id: ID @doc(description: "Configurable option id")
    attribute_id: ID @doc(description: "Attribute id from the attribute collection")
    attribute_code: String @doc(description: "Attribute code from the attribute collection")
    label: String @doc(description: "Configurable option name - Size, Color ...")
    position: Int @doc(description: "Configurable option position on the product page")
    values: [ConfigurableOptionValue] @doc(description: "Available configurable options")
    product_id: ID @doc(description: "Product Id this option is assigned to")
}

type ProductTierPrice @doc(description: "The ProductTierPrice object defines a tier price, which is a quantity discount offered to a specific customer group.") {
    customer_group_id: String @doc(description: "The ID of the customer group.")
    qty: Float @doc(description: "The number of items that must be purchased to qualify for tier pricing.")
    value: Float @doc(description: "The price of the fixed price item.")
    percentage_value: Float @doc(description: "The percentage discount of the item.")
    website_id: Float @doc(description: "The ID assigned to the website.")
}


type MediaGalleryItem @doc(description: "Contains basic information about a product image or video.")  {
    image: String @doc(description: "The relative URL of the product image or video.")
    pos: Int @doc(description: "Position in the gallery")
    typ: String @doc(description: "Media type") @deprecated(reason: "Use `type` instead")
    type: String @doc(description: "Media type")
    url: String @doc(description: "The URL of the product image or video.")
    lab: String @doc(description: "Media label") @deprecated(reason: "Use `label` instead")
    label: String @doc(description: "The label of the product image or video.")
    vid: JSON @doc(description: "The Video data.") @deprecated(reason: "Use `video` instead")
    video: JSON @doc(description: "The Video data.")
}

type StockItem {
    item_id: ID @doc(description: "Stock item id")
    product_id: ID @doc(description: "Product identifier")
    stock_id: ID @doc(description: "Stock id")
    qty: Float @doc(description: "Stock quantity")
    is_in_stock: Boolean @doc(description: "Is item on stock")
    is_qty_decimal: Boolean @doc(description: "Is quantity decimal")
    min_qty: Float @doc(description: "Min sale quantity")
    max_sale_qty: Float @doc(description: "Max sale quantity")
    backorders: Int @doc(description: "Does this item support backorders")
    qty_increments: Float @doc(description: "How quantity increments")
}

input StockFilterInput @doc(description: "StockFilterInput defines the filters to be used in the search for a product. A filter contains at least one attribute, a comparison operator, and the value that is being searched for.") {
    is_in_stock: FilterTypeInput @doc(description: "Is product in stock")
    qty: FilterTypeInput @doc(description: "Product quantity")
}

input CategoryBindingFilterInput @doc(description: "CategoryBindingFilterInput defines the filters to be used in the search for a product. A filter contains at least one attribute, a comparison operator, and the value that is being searched for.") {
    category_id: FilterTypeInput @doc(description: "Category id")
}

input ProductFilterInput @doc(description: "ProductFilterInput defines the filters to be used in the search. A filter contains at least one attribute, a comparison operator, and the value that is being searched for.") {
    id: FilterTypeInput @doc(description: "The id - an unique product identifier")
    name: FilterTypeInput @doc(description: "The product name. Customers use this name to identify the product.")
    sku: FilterTypeInput @doc(description: "A number or code assigned to a product to identify the product, options, price, and manufacturer.")
    description: FilterTypeInput @doc(description: "Detailed information about the product. The value can include simple HTML tags.")
    short_description: FilterTypeInput @doc(description: "A short description of the product. Its use depends on the theme.")
    price: FilterTypeInput @doc(description: "The price of an item.")
    special_price: FilterTypeInput @doc(description: "The discounted price of the product. Do not include the currency code.")
    special_from_date: FilterTypeInput @doc(description: "The beginning date that a product has a special price.")
    special_to_date: FilterTypeInput @doc(description: "The end date that a product has a special price.")
    weight: FilterTypeInput @doc(description: "The weight of the item, in units defined by the store.")
    category: CategoryBindingFilterInput @doc(description: "The category this product belongs to")
    manufacturer: FilterTypeInput @doc(description: "A number representing the product's manufacturer.")
    meta_title: FilterTypeInput @doc(description: "A string that is displayed in the title bar and tab of the browser and in search results lists.")
    meta_keyword: FilterTypeInput @doc(description: "A comma-separated list of keywords that are visible only to search engines.")
    meta_description: FilterTypeInput @doc(description: "A brief overview of the product for search results listings, maximum 255 characters.")
    image: FilterTypeInput @doc(description: "The relative path to the main image on the product page.")
    small_image: FilterTypeInput @doc(description: "The relative path to the small image, which is used on catalog pages.")
    thumbnail: FilterTypeInput @doc(description: "The relative path to the product's thumbnail image.")
    tier_price: FilterTypeInput @doc(description: "The price when tier pricing is in effect and the items purchased threshold has been reached.")
    news_from_date: FilterTypeInput @doc(description: "The beginning date for new product listings, and determines if the product is featured as a new product.")
    news_to_date: FilterTypeInput @doc(description: "The end date for new product listings.")
    custom_layout_update: FilterTypeInput @doc(description: "XML code that is applied as a layout update to the product page.")
    min_price: FilterTypeInput @doc(description:"The numeric minimal price of the product. Do not include the currency code.")
    max_price: FilterTypeInput @doc(description:"The numeric maximal price of the product. Do not include the currency code.")
    category_ids: FilterTypeInput @doc(description: "Category ID the product belongs to.")
    options_container: FilterTypeInput @doc(description: "If the product has multiple options, determines where they appear on the product page.")
    required_options: FilterTypeInput @doc(description: "Indicates whether the product has required options.")
    has_options: FilterTypeInput @doc(description: "Indicates whether additional attributes have been created for the product.")
    image_label: FilterTypeInput @doc(description: "The label assigned to a product image.")
    small_image_label: FilterTypeInput @doc(description: "The label assigned to a product's small image.")
    thumbnail_label: FilterTypeInput @doc(description: "The label assigned to a product's thumbnail image.")
    created_at: FilterTypeInput @doc(description: "Timestamp indicating when the product was created.")
    updated_at: FilterTypeInput @doc(description: "Timestamp indicating when the product was updated.")
    country_of_manufacture: FilterTypeInput @doc(description: "The product's country of origin.")
    custom_layout: FilterTypeInput @doc(description: "The name of a custom layout.")
    gift_message_available: FilterTypeInput @doc(description: "Indicates whether a gift message is available.")
    visibility: FilterTypeInput @doc(description: "The product visibility. Customers use this visibility to identify the product.")
    type_id: FilterTypeInput @doc(description: "The product type - simple, configurable, virtual, downloadable, grouped")
    is_in_stock: FilterTypeInput @doc(description: "Is product in stock")
    stock: StockFilterInput @doc(description: "Product stock information")
    status: FilterTypeInput @doc(description: "Product status information")
    size: FilterTypeInput @doc(description: "The product size. Customers use this size to identify the product.")
    size_options: FilterTypeInput @doc(description: "The product sizes for all configurable_children variants. Customers use this size to identify the product.")
    color: FilterTypeInput @doc(description: "The product color. Customers use this color to identify the product.")
    color_options: FilterTypeInput @doc(description: "The product colors for all configurable_children variants. Customers use this color to identify the product.")    
    or: ProductFilterInput @doc(description: "The keyword required to perform a logical OR comparison.")
}

type CategoryBinding @doc(description: "CategoryBinding defines the category anchor which product is bound to") {
    category_id: ID @doc(description: "Category identifier")
    name: String @doc(description: "Category name")
    slug: ID @doc(description: "Category unique slug")
    path: ID @doc(description: "Category url path")
}

#type LayerFilter {
#    name: String @doc(description: "Layered navigation filter name")
#    request_var: String @doc(description: "Request variable name for filter query")
#    filter_items_count: Int @doc(description: "Count of filter items in filter group")
#    filter_items: [LayerFilterItemInterface] @doc(description: "Array of filter items")
#}

#interface LayerFilterItemInterface {
#    label: String @doc(description: "Filter label")
#    value_string: String @doc(description: "Value for filter request variable to be used in query")
#    items_count: Int @doc(description: "Count of items by filter")
#}

#type LayerFilterItem implements LayerFilterItemInterface {
#}

type SortField {
    value: String @doc(description: "Attribute code of sort field")
    label: String @doc(description: "Label of sort field")
}

type SortFields @doc(description: "SortFields contains a default value for sort fields and all available sort fields") {
    default: String @doc(description: "Default value of sort fields")
    options: [SortField] @doc(description: "Available sort fields")
}

enum SortEnum {
    ASC
    DESC
}
